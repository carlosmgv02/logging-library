name: 'Check Release Relevance'
description: 'Determines if a release should be created based on file changes'

inputs:
  base-ref:
    description: 'Base reference for comparison'
    required: true
    default: 'origin/master'
  head-ref:
    description: 'Head reference for comparison'
    required: true
    default: 'HEAD'

outputs:
  should-release:
    description: 'Whether a release should be created'
    value: ${{ steps.check.outputs.should-release }}
  reason:
    description: 'Reason for the decision'
    value: ${{ steps.check.outputs.reason }}
  version-type:
    description: 'Type of version increment (major, minor, patch)'
    value: ${{ steps.check.outputs.version-type }}
  next-version:
    description: 'The next version number that would be released'
    value: ${{ steps.check.outputs.next-version }}

runs:
  using: "composite"
  steps:
    - name: Check for relevant changes
      id: check
      shell: bash
      run: |
        echo "Checking for release-relevant changes between ${{ inputs.base-ref }} and ${{ inputs.head-ref }}"

        # Get list of changed files
        CHANGED_FILES=$(git diff --name-only ${{ inputs.base-ref }}...${{ inputs.head-ref }})

        echo "Changed files:"
        echo "$CHANGED_FILES"

        # Define patterns that should trigger a release
        RELEASE_PATTERNS=(
          "src/"
          "pom.xml"
          "*.java"
          "*.xml"
          "*.yaml"
          "*.yml"
          "*.properties"
        )

        # Define patterns that should NOT trigger a release
        IGNORE_PATTERNS=(
          ".github/"
          "*.md"
          ".gitignore"
          "LICENSE"
          "CHANGELOG.md"
        )

        SHOULD_RELEASE="false"
        RELEVANT_CHANGES=""

        # Check each changed file
        while IFS= read -r file; do
          if [ -z "$file" ]; then
            continue
          fi

          # Skip if file matches ignore patterns
          SHOULD_IGNORE="false"
          for ignore_pattern in "${IGNORE_PATTERNS[@]}"; do
            if [[ "$file" == *"$ignore_pattern"* ]]; then
              SHOULD_IGNORE="true"
              break
            fi
          done

          if [ "$SHOULD_IGNORE" = "true" ]; then
            echo "Ignoring: $file"
            continue
          fi

          # Check if file matches release patterns
          for pattern in "${RELEASE_PATTERNS[@]}"; do
            if [[ "$file" == *"$pattern"* ]]; then
              SHOULD_RELEASE="true"
              RELEVANT_CHANGES="$RELEVANT_CHANGES$file\n"
              echo "Relevant change found: $file"
              break
            fi
          done
        done <<< "$CHANGED_FILES"

        # Determine reason
        if [ "$SHOULD_RELEASE" = "true" ]; then
          REASON="Found relevant changes in source code or configuration files"
          echo "âœ… Release should be created"
          echo "Relevant files changed:"
          echo -e "$RELEVANT_CHANGES"
        else
          REASON="No relevant changes found (only documentation or CI changes)"
          echo "â­ï¸ No release needed"
          echo "All changes are in documentation or CI files"
        fi

        # Determine version increment type and calculate next version if release is needed
        VERSION_TYPE="patch"
        NEXT_VERSION=""
        
        if [ "$SHOULD_RELEASE" = "true" ]; then
          # Get commit messages for conventional commit analysis
          COMMITS=$(git log --oneline ${{ inputs.base-ref }}..${{ inputs.head-ref }})
          echo "Analyzing commits for version type:"
          echo "$COMMITS"

          # Determine version type based on conventional commits
          if echo "$COMMITS" | grep -qE "^[a-f0-9]+ (feat|feature)(\(.+\))?!:"; then
            VERSION_TYPE="major"
            echo "Found breaking feature, using major version"
          elif echo "$COMMITS" | grep -qE "^[a-f0-9]+ .+!:"; then
            VERSION_TYPE="major"
            echo "Found breaking change, using major version"
          elif echo "$COMMITS" | grep -qE "^[a-f0-9]+ (feat|feature)(\(.+\))?:"; then
            VERSION_TYPE="minor"
            echo "Found feature, using minor version"
          else
            VERSION_TYPE="patch"
            echo "No major/minor changes found, using patch version"
          fi

          # Calculate next version
          if command -v mvn >/dev/null 2>&1; then
            CURRENT_VERSION=$(mvn help:evaluate -Dexpression=project.version -q -DforceStdout 2>/dev/null || echo "0.0.1-SNAPSHOT")
            BASE_VERSION=${CURRENT_VERSION%-SNAPSHOT}
            
            IFS='.' read -r -a version_parts <<< "$BASE_VERSION"
            MAJOR=${version_parts[0]:-0}
            MINOR=${version_parts[1]:-0}
            PATCH=${version_parts[2]:-1}

            case $VERSION_TYPE in
              "major")
                NEW_MAJOR=$((MAJOR + 1))
                NEXT_VERSION="${NEW_MAJOR}.0.0"
                ;;
              "minor")
                NEW_MINOR=$((MINOR + 1))
                NEXT_VERSION="${MAJOR}.${NEW_MINOR}.0"
                ;;
              "patch"|*)
                NEW_PATCH=$((PATCH + 1))
                NEXT_VERSION="${MAJOR}.${MINOR}.${NEW_PATCH}"
                ;;
            esac
            
            echo "Current version: $CURRENT_VERSION"
            echo "Next version would be: $NEXT_VERSION"
          fi
        fi

        echo "should-release=$SHOULD_RELEASE" >> $GITHUB_OUTPUT
        echo "reason=$REASON" >> $GITHUB_OUTPUT
        echo "version-type=$VERSION_TYPE" >> $GITHUB_OUTPUT
        echo "next-version=$NEXT_VERSION" >> $GITHUB_OUTPUT

        echo ""
        echo "ðŸ“‹ Summary:"
        echo "Should create release: $SHOULD_RELEASE"
        echo "Reason: $REASON"
        if [ "$SHOULD_RELEASE" = "true" ]; then
          echo "Version type: $VERSION_TYPE"
          echo "Next version: $NEXT_VERSION"
        fi