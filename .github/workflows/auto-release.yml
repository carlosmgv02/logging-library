name: Production Release

on:
  push:
    branches: [master, main]
  workflow_dispatch:
    inputs:
      version_type:
        description: 'Version increment type'
        required: true
        type: choice
        options:
          - patch
          - minor
          - major
        default: 'patch'

permissions:
  contents: write
  packages: write
  pull-requests: write

jobs:
  production-release:
    name: Create Production Release
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Configure Git
        run: |
          git config --global user.name 'github-actions[bot]'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'

      - name: Check if release is needed
        id: release_check
        uses: ./.github/actions/check-release-relevance
        with:
          base-ref: ${{ github.event.before && github.event.before != '0000000000000000000000000000000000000000' && github.event.before || 'HEAD~1' }}
          head-ref: ${{ github.sha }}

      - name: Skip if no relevant changes (except manual)
        if: github.event_name != 'workflow_dispatch' && steps.release_check.outputs.should-release != 'true'
        run: |
          echo "‚è≠Ô∏è Skipping release - no relevant changes found"
          echo "Reason: ${{ steps.release_check.outputs.reason }}"
          exit 0

      - name: Determine version increment
        id: version_info
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            VERSION_TYPE="${{ github.event.inputs.version_type }}"
            echo "Manual trigger: Using $VERSION_TYPE increment"
          else
            VERSION_TYPE="${{ steps.release_check.outputs.version-type }}"
            echo "Auto-detected: Using $VERSION_TYPE increment"
          fi
          
          # Get current version from master (should be a release version, not SNAPSHOT)
          CURRENT_VERSION=$(mvn help:evaluate -Dexpression=project.version -q -DforceStdout)
          echo "Current master version: $CURRENT_VERSION"
          
          # If it's a SNAPSHOT, remove the SNAPSHOT suffix for base calculation
          BASE_VERSION=${CURRENT_VERSION%-SNAPSHOT}
          
          # Calculate new release version
          IFS='.' read -r -a version_parts <<< "$BASE_VERSION"
          MAJOR=${version_parts[0]}
          MINOR=${version_parts[1]}
          PATCH=${version_parts[2]}
          
          case $VERSION_TYPE in
            "major")
              NEW_MAJOR=$((MAJOR + 1))
              RELEASE_VERSION="${NEW_MAJOR}.0.0"
              ;;
            "minor")
              NEW_MINOR=$((MINOR + 1))
              RELEASE_VERSION="${MAJOR}.${NEW_MINOR}.0"
              ;;
            "patch"|*)
              NEW_PATCH=$((PATCH + 1))
              RELEASE_VERSION="${MAJOR}.${MINOR}.${NEW_PATCH}"
              ;;
          esac

          # Calculate next development version
          IFS='.' read -r -a rel_parts <<< "$RELEASE_VERSION"
          REL_MAJOR=${rel_parts[0]}
          REL_MINOR=${rel_parts[1]}
          REL_PATCH=${rel_parts[2]}
          NEXT_DEV_PATCH=$((REL_PATCH + 1))
          NEXT_DEV_VERSION="${REL_MAJOR}.${REL_MINOR}.${NEXT_DEV_PATCH}-SNAPSHOT"
          
          echo "version_type=$VERSION_TYPE" >> $GITHUB_OUTPUT
          echo "current_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          echo "release_version=$RELEASE_VERSION" >> $GITHUB_OUTPUT
          echo "next_dev_version=$NEXT_DEV_VERSION" >> $GITHUB_OUTPUT
          
          echo "üìã Version Plan:"
          echo "  Current: $CURRENT_VERSION"
          echo "  Release: $RELEASE_VERSION ($VERSION_TYPE increment)"
          echo "  Next Dev: $NEXT_DEV_VERSION"

      - name: Update to release version
        run: |
          RELEASE_VERSION="${{ steps.version_info.outputs.release_version }}"
          
          echo "Updating to release version: $RELEASE_VERSION"
          mvn versions:set -DnewVersion=$RELEASE_VERSION -DgenerateBackupPoms=false
          
          echo "‚úÖ Version updated to $RELEASE_VERSION"

      - name: Build and Test Release
        uses: ./.github/actions/build-and-test
        with:
          java-version: '17'
          run-quality-checks: 'true'
          skip-tests: 'false'

      - name: Update CHANGELOG
        run: |
          RELEASE_VERSION="${{ steps.version_info.outputs.release_version }}"
          VERSION_TYPE="${{ steps.version_info.outputs.version_type }}"
          TODAY=$(date +"%Y-%m-%d")

          # Create or update CHANGELOG.md
          if [ ! -f CHANGELOG.md ]; then
            echo "# Changelog" > CHANGELOG.md
            echo "" >> CHANGELOG.md
          fi

          # Prepare changelog entry
          TEMP_CHANGELOG=$(mktemp)
          echo "# Changelog" > $TEMP_CHANGELOG
          echo "" >> $TEMP_CHANGELOG
          echo "## [${RELEASE_VERSION}] - ${TODAY}" >> $TEMP_CHANGELOG
          echo "" >> $TEMP_CHANGELOG

          # Add version type information
          case $VERSION_TYPE in
            "major")
              echo "### üöÄ Major Release - Breaking Changes" >> $TEMP_CHANGELOG
              ;;
            "minor")
              echo "### ‚ú® Minor Release - New Features" >> $TEMP_CHANGELOG
              ;;
            "patch")
              echo "### üêõ Patch Release - Bug Fixes" >> $TEMP_CHANGELOG
              ;;
          esac

          echo "" >> $TEMP_CHANGELOG
          echo "### Features & Improvements" >> $TEMP_CHANGELOG
          echo "- Professional logging library with hexagonal architecture" >> $TEMP_CHANGELOG
          echo "- System validation with real connectivity checks" >> $TEMP_CHANGELOG
          echo "- Sensitive data filtering with configurable patterns" >> $TEMP_CHANGELOG
          echo "- OpenTelemetry tracing integration" >> $TEMP_CHANGELOG
          echo "- ELK stack integration for centralized logging" >> $TEMP_CHANGELOG
          echo "" >> $TEMP_CHANGELOG

          # Add existing changelog content
          if [ -f CHANGELOG.md ]; then
            tail -n +2 CHANGELOG.md >> $TEMP_CHANGELOG
          fi

          mv $TEMP_CHANGELOG CHANGELOG.md

          echo "‚úÖ CHANGELOG updated for version $RELEASE_VERSION"

      - name: Commit release version
        run: |
          RELEASE_VERSION="${{ steps.version_info.outputs.release_version }}"
          VERSION_TYPE="${{ steps.version_info.outputs.version_type }}"

          git add pom.xml CHANGELOG.md
          git commit -m "chore: release version $RELEASE_VERSION

          Production release $RELEASE_VERSION ($VERSION_TYPE increment)
          
          - Updated version to $RELEASE_VERSION
          - Updated CHANGELOG.md
          - All tests passing
          - Quality checks completed"

      - name: Create release tag
        run: |
          RELEASE_VERSION="${{ steps.version_info.outputs.release_version }}"
          TAG_NAME="v${RELEASE_VERSION}"
          
          echo "Creating release tag: $TAG_NAME"
          
          git tag -a $TAG_NAME -m "Release ${RELEASE_VERSION}

          Professional Logging Library ${RELEASE_VERSION}
          
          üèóÔ∏è Enterprise Features:
          - Hexagonal Architecture with domain-driven design
          - System Validation with real connectivity checks
          - Sensitive Data Filtering with configurable patterns
          - OpenTelemetry Integration for distributed tracing
          - ELK Stack Integration for centralized logging
          
          üì¶ Installation:
          <dependency>
              <groupId>com.carlosmgv02</groupId>
              <artifactId>logging-library</artifactId>
              <version>${RELEASE_VERSION}</version>
          </dependency>"
          
          echo "Pushing tag and changes..."
          git push origin ${{ github.ref_name }}
          git push origin $TAG_NAME
          
          echo "‚úÖ Tag $TAG_NAME created and pushed"

      - name: Publish to GitHub Packages
        run: |
          echo "Publishing release to GitHub Packages..."
          mvn deploy -DskipTests
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Cleanup old snapshots
        run: |
          RELEASE_VERSION="${{ steps.version_info.outputs.release_version }}"
          
          echo "üßπ Cleaning up obsolete snapshots before creating release..."
          
          # Get all releases
          ALL_RELEASES=$(gh release list --limit 100 --json tagName,isPrerelease,createdAt)
          
          # Find snapshots that should be cleaned up
          echo "Looking for snapshots to cleanup..."
          
          # Delete old snapshot releases (keep only the latest 2 snapshots)
          SNAPSHOT_RELEASES=$(echo "$ALL_RELEASES" | jq -r '.[] | select(.isPrerelease == true and (.tagName | contains("snapshot-"))) | .tagName' | head -n +10)
          
          SNAPSHOT_COUNT=0
          for snapshot in $SNAPSHOT_RELEASES; do
            if [ $SNAPSHOT_COUNT -ge 2 ]; then
              echo "Deleting old snapshot: $snapshot"
              gh release delete $snapshot --yes --cleanup-tag || echo "Failed to delete $snapshot"
            else
              echo "Keeping recent snapshot: $snapshot"
            fi
            SNAPSHOT_COUNT=$((SNAPSHOT_COUNT + 1))
          done
          
          # Also cleanup any snapshots that match the version being released
          BASE_VERSION=${RELEASE_VERSION}
          MATCHING_SNAPSHOTS=$(echo "$ALL_RELEASES" | jq -r --arg version "$BASE_VERSION" '.[] | select(.isPrerelease == true and (.tagName | contains($version + "-SNAPSHOT"))) | .tagName')
          
          for snapshot in $MATCHING_SNAPSHOTS; do
            echo "Deleting snapshot for released version: $snapshot"
            gh release delete $snapshot --yes --cleanup-tag || echo "Failed to delete $snapshot"
          done
          
          echo "‚úÖ Snapshot cleanup completed"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Create GitHub Release
        run: |
          RELEASE_VERSION="${{ steps.version_info.outputs.release_version }}"
          VERSION_TYPE="${{ steps.version_info.outputs.version_type }}"
          TAG_NAME="v${RELEASE_VERSION}"
          
          # Read changelog content for this version
          CHANGELOG_CONTENT=""
          if [ -f CHANGELOG.md ]; then
            CHANGELOG_CONTENT=$(sed -n "/## \[${RELEASE_VERSION}\]/,/## \[/p" CHANGELOG.md | sed '$ d' | tail -n +2)
          fi
          
          gh release create $TAG_NAME \
            --title "üöÄ Professional Logging Library ${RELEASE_VERSION}" \
            --notes "## üöÄ Professional Logging Library ${RELEASE_VERSION}

          ${CHANGELOG_CONTENT:-Auto-generated release with enhanced logging capabilities}

            ### üèóÔ∏è Enterprise Features
            - **Hexagonal Architecture** with domain-driven design
            - **System Validation** with real connectivity checks
            - **Sensitive Data Filtering** with configurable patterns
            - **OpenTelemetry Integration** for distributed tracing
            - **ELK Stack Integration** for centralized logging

            ### üì¶ Installation

            #### Maven
            \`\`\`xml
            <dependency>
                <groupId>com.carlosmgv02</groupId>
                <artifactId>logging-library</artifactId>
              <version>${RELEASE_VERSION}</version>
            </dependency>
            \`\`\`

          ### üîß Configuration
          See [CONSUMER_SETUP.md](.github/CONSUMER_SETUP.md) for GitHub Packages setup instructions.

          ### üìö Documentation
          - [README.md](README.md) - Complete usage guide
          - [CICD_ARCHITECTURE.md](.github/CICD_ARCHITECTURE.md) - CI/CD pipeline documentation
          - [Javadoc](https://github.com/carlosmgv02/logging-library/releases/download/${TAG_NAME}/logging-library-${RELEASE_VERSION}-javadoc.jar) - API documentation

          ---
          **Full Changelog:** [View Changes](https://github.com/carlosmgv02/logging-library/compare/v$(git describe --tags --abbrev=0 HEAD^)...${TAG_NAME})" \
            target/*.jar
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Update development branch
        run: |
          NEXT_DEV_VERSION="${{ steps.version_info.outputs.next_dev_version }}"
          RELEASE_VERSION="${{ steps.version_info.outputs.release_version }}"
          
          echo "Updating development branch to next version: $NEXT_DEV_VERSION"
          
          # Fetch and checkout development
          git fetch origin development
          git checkout development
          
          # Update to next development version
          mvn versions:set -DnewVersion=$NEXT_DEV_VERSION -DgenerateBackupPoms=false
          
          # Commit the version update
          git add pom.xml
          git commit -m "chore: bump development version to $NEXT_DEV_VERSION

          Automatic version bump after release $RELEASE_VERSION
          
          - Updated development version to $NEXT_DEV_VERSION
          - Ready for next development cycle"
          
          # Push to development
          git push origin development
          
          echo "‚úÖ Development branch updated to $NEXT_DEV_VERSION"

      - name: Generate release summary
        run: |
          RELEASE_VERSION="${{ steps.version_info.outputs.release_version }}"
          VERSION_TYPE="${{ steps.version_info.outputs.version_type }}"
          NEXT_DEV_VERSION="${{ steps.version_info.outputs.next_dev_version }}"
          
          echo "## üéâ Production Release Created" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ‚úÖ Release Details" >> $GITHUB_STEP_SUMMARY
          echo "- **Version:** \`$RELEASE_VERSION\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Type:** $VERSION_TYPE release" >> $GITHUB_STEP_SUMMARY
          echo "- **Tag:** \`v$RELEASE_VERSION\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Published:** GitHub Packages ‚úÖ" >> $GITHUB_STEP_SUMMARY
          echo "- **Release:** [View Release](https://github.com/${{ github.repository }}/releases/tag/v$RELEASE_VERSION) ‚úÖ" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üîÑ Branch Updates" >> $GITHUB_STEP_SUMMARY
          echo "- **Master:** Updated to \`$RELEASE_VERSION\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Development:** Updated to \`$NEXT_DEV_VERSION\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üì¶ Installation" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`xml" >> $GITHUB_STEP_SUMMARY
          echo "<dependency>" >> $GITHUB_STEP_SUMMARY
          echo "    <groupId>com.carlosmgv02</groupId>" >> $GITHUB_STEP_SUMMARY
          echo "    <artifactId>logging-library</artifactId>" >> $GITHUB_STEP_SUMMARY
          echo "    <version>$RELEASE_VERSION</version>" >> $GITHUB_STEP_SUMMARY
          echo "</dependency>" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üöÄ Next Steps" >> $GITHUB_STEP_SUMMARY
          echo "1. **Update your projects** to use version \`$RELEASE_VERSION\`" >> $GITHUB_STEP_SUMMARY
          echo "2. **Continue development** on \`development\` branch (now \`$NEXT_DEV_VERSION\`)" >> $GITHUB_STEP_SUMMARY
          echo "3. **Monitor** the release for any issues" >> $GITHUB_STEP_SUMMARY